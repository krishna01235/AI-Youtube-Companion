let fetch;
let parseStringPromise;
const { Innertube } = require("youtubei.js"); // ✅ add youtubei.js for fallback

// Initialize dependencies
async function initializeDependencies() {
  if (!fetch) {
    if (typeof globalThis !== 'undefined' && globalThis.fetch) {
      fetch = globalThis.fetch;
    } else {
      const nodeFetch = require("node-fetch");
      fetch = nodeFetch.default || nodeFetch;
    }
  }

  if (!parseStringPromise) {
    const xml2js = require("xml2js");
    parseStringPromise = xml2js.parseStringPromise;
  }
}

/**
 * Scraping version (your existing logic)
 */
async function getTranscriptScraping(videoUrlOrId, language = "en") {
  await initializeDependencies();

  const videoId = extractVideoId(videoUrlOrId);
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;

  const response = await fetch(videoUrl);
  const html = await response.text();
  const apiKeyMatch = html.match(/"INNERTUBE_API_KEY":"([^"]+)"/);

  if (!apiKeyMatch) {
    throw new Error("Video unavailable or private");
  }

  const apiKey = apiKeyMatch[1];

  const playerResponse = await fetch(`https://www.youtube.com/youtubei/v1/player?key=${apiKey}`, {
    method: "POST",
    headers: { 
      "Content-Type": "application/json",
      "User-Agent": "com.google.android.youtube/20.10.38 (Linux; U; Android 13) gzip"
    },
    body: JSON.stringify({
      context: {
        client: {
          clientName: "ANDROID",
          clientVersion: "20.10.38",
          androidSdkVersion: 33,
          osName: "Android",
          osVersion: "13",
        }
      },
      videoId
    })
  });

  const playerData = await playerResponse.json();
  const tracks = playerData?.captions?.playerCaptionsTracklistRenderer?.captionTracks;

  if (!tracks || tracks.length === 0) {
    throw new Error("No captions found");
  }

  let track = tracks.find(t => t.languageCode === language) || tracks[0];
  const baseUrl = track.baseUrl.replace(/&fmt=\w+$/, "");
  const xmlResponse = await fetch(baseUrl);
  const xml = await xmlResponse.text();
  const parsed = await parseStringPromise(xml);

  if (!parsed?.transcript?.text) {
    throw new Error("Invalid caption format");
  }

  const structuredTranscript = parsed.transcript.text
    .map(entry => ({
      text: entry._ || "",
      start: parseFloat(entry.$.start || 0),
      duration: parseFloat(entry.$.dur || 0),
    }))
    .filter(entry => entry.text.trim().length > 0);

  const plainText = structuredTranscript
    .map(entry => entry.text)
    .join(" ")
    .replace(/\[.*?\]/g, "")
    .replace(/\s+/g, " ")
    .trim();

  return {
    structured: structuredTranscript,
    plainText,
    trackInfo: {
      name: track.name?.simpleText,
      language: track.languageCode,
      isAutoGenerated: track.kind === "asr"
    }
  };
}

/**
 * Fallback: youtubei.js
 */
async function getTranscriptWithYTJS(videoUrlOrId, language = "en") {
  const videoId = extractVideoId(videoUrlOrId);
  const yt = await Innertube.create();
  const info = await yt.getInfo(videoId);

  if (!info.captions?.caption_tracks?.length) {
    throw new Error("No captions found");
  }

  let track = info.captions.caption_tracks.find(t => t.language_code === language) 
            || info.captions.caption_tracks[0];

  const transcript = await track.download();
  const structuredTranscript = transcript.map(entry => ({
    text: entry.text,
    start: entry.start,
    duration: entry.duration,
  }));

  const plainText = structuredTranscript.map(e => e.text).join(" ").trim();

  return {
    structured: structuredTranscript,
    plainText,
    trackInfo: {
      name: track.name,
      language: track.language_code,
      isAutoGenerated: track.kind === "asr"
    }
  };
}

/**
 * Main entry: try scraping, fallback to youtubei.js
 */
async function getTranscript(videoUrlOrId, language = "en") {
  let transcript;
  try {
    transcript = await getTranscriptScraping(videoUrlOrId, language);
  } catch (e) {
    console.warn("⚠️ Scraping failed, trying youtubei.js fallback:", e.message);
    transcript = await getTranscriptWithYTJS(videoUrlOrId, language);
  }
  return transcript;
}

/**
 * Extract video ID from YouTube URL
 */
function extractVideoId(videoUrlOrId) {
  if (/^[a-zA-Z0-9_-]{11}$/.test(videoUrlOrId)) {
    return videoUrlOrId;
  }
  
  try {
    const url = new URL(videoUrlOrId);
    if (url.hostname.includes('youtube.com')) {
      const videoId = url.searchParams.get('v');
      if (videoId) return videoId;
    }
    if (url.hostname.includes('youtu.be')) {
      return url.pathname.slice(1);
    }
    if (url.pathname.includes('/embed/')) {
      return url.pathname.split('/embed/')[1]?.split('?')[0];
    }
  } catch (err) {
    const match = videoUrlOrId.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/);
    if (match) return match[1];
  }
  return videoUrlOrId;
}

module.exports = { 
  getTranscript,
  extractVideoId 
};
