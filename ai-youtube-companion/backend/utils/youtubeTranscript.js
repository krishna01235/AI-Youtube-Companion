// utils/transcript.js
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));
const xml2js = require("xml2js");
let parseStringPromise = xml2js.parseStringPromise;

async function getTranscript(videoUrlOrId, language = "en") {
  const videoId = extractVideoId(videoUrlOrId);
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;

  // Fetch video page HTML to extract INNERTUBE_API_KEY and context params
  const response = await fetch(videoUrl, { headers: { "User-Agent": "Mozilla/5.0" } });
  const html = await response.text();

  const apiKeyMatch = html.match(/"INNERTUBE_API_KEY":"([^"]+)"/);
  const clientVersionMatch = html.match(/"INNERTUBE_CLIENT_VERSION":"([^"]+)"/);
  if (!apiKeyMatch || !clientVersionMatch) throw new Error("Video unavailable or API key not found");
  const apiKey = apiKeyMatch[1];

  // Use dynamic clientVersion from page for best reliability
  const clients = [
    { clientName: "WEB", clientVersion: clientVersionMatch[1], ua: "Mozilla/5.0" },
    { clientName: "ANDROID", clientVersion: "20.10.38", ua: "com.google.android.youtube/20.10.38 (Linux; U; Android 13) gzip" }
  ];

  let lastError = null;

  for (const client of clients) {
    try {
      // Call the internal player API
      const playerResponse = await fetch(`https://www.youtube.com/youtubei/v1/player?key=${apiKey}`, {
        method: "POST",
        headers: { "Content-Type": "application/json", "User-Agent": client.ua },
        body: JSON.stringify({
          context: { client: { clientName: client.clientName, clientVersion: client.clientVersion } },
          videoId
        })
      });

      const playerData = await playerResponse.json();
      const tracks =
        playerData?.captions?.playerCaptionsTracklistRenderer?.captionTracks ||
        playerData?.captions?.playerCaptionsRenderer?.captionTracks;

      if (!tracks || tracks.length === 0) throw new Error(`No captions found with client ${client.clientName}`);

      // Pick requested language or default to first
      const track = tracks.find(t => t.languageCode === language) || tracks[0];

      // Fetch caption XML (remove existing fmt param, add needed ones)
      const xmlUrl = track.baseUrl.split("&fmt=")[0] + "&fmt=srv3"; 
      const xmlResponse = await fetch(xmlUrl, { headers: { "User-Agent": client.ua } });
      const xml = await xmlResponse.text();
      const parsed = await parseStringPromise(xml);

      if (!parsed?.transcript?.text) throw new Error("Invalid caption format");

      const structured = parsed.transcript.text
        .map(e => ({
          text: e._?.trim() || "",
          start: parseFloat(e.$.start || 0),
          duration: parseFloat(e.$.dur || 0)
        }))
        .filter(e => e.text.length > 0);

      const plainText = structured.map(e => e.text).join(" ").replace(/\s+/g, " ").trim();

      return {
        structured,
        plainText,
        trackInfo: {
          name: track.name?.simpleText || null,
          language: track.languageCode,
          isAutoGenerated: track.kind === "asr"
        }
      };
    } catch (err) {
      lastError = err;
      continue;
    }
  }

  throw new Error(`All clients failed. Last error: ${lastError?.message}`);
}

function extractVideoId(videoUrlOrId) {
  if (/^[a-zA-Z0-9_-]{11}$/.test(videoUrlOrId)) return videoUrlOrId;
  try {
    const url = new URL(videoUrlOrId);
    if (url.hostname.includes("youtube.com")) return url.searchParams.get("v");
    if (url.hostname.includes("youtu.be")) return url.pathname.slice(1);
    if (url.pathname.includes("/embed/")) return url.pathname.split("/embed/")[1]?.split("?")[0];
  } catch {}
  const match = videoUrlOrId.match(
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/
  );
  return match ? match[1] : videoUrlOrId;
}

module.exports = { getTranscript, extractVideoId };
