const xml2js = require("xml2js");
let parseStringPromise = xml2js.parseStringPromise;

async function getTranscript(videoUrlOrId, language = "en") {
  const videoId = extractVideoId(videoUrlOrId);
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;

  const response = await fetch(videoUrl, { headers: { 'User-Agent': 'Mozilla/5.0' } });
  const html = await response.text();
  const apiKeyMatch = html.match(/"INNERTUBE_API_KEY":"([^"]+)"/);
  if (!apiKeyMatch) throw new Error("Video unavailable or private");
  const apiKey = apiKeyMatch[1];

  const clients = [
    { clientName: "WEB", clientVersion: "2.20231201.01.00", ua: "Mozilla/5.0" },
    { clientName: "ANDROID", clientVersion: "20.10.38", ua: "com.google.android.youtube/20.10.38 (Linux; U; Android 13) gzip" }
  ];

  let lastError = null;

  for (const client of clients) {
    try {
      const playerResponse = await fetch(`https://www.youtube.com/youtubei/v1/player?key=${apiKey}`, {
        method: "POST",
        headers: { "Content-Type": "application/json", "User-Agent": client.ua },
        body: JSON.stringify({
          context: { client: { clientName: client.clientName, clientVersion: client.clientVersion } },
          videoId
        })
      });

      const playerData = await playerResponse.json();
      let tracks = playerData?.captions?.playerCaptionsTracklistRenderer?.captionTracks
                || playerData?.captions?.playerCaptionsRenderer?.captionTracks;

      if (!tracks || tracks.length === 0) throw new Error(`No captions found with client ${client.clientName}`);

      let track = tracks.find(t => t.languageCode === language) || tracks[0];

      const xmlResponse = await fetch(track.baseUrl.replace(/&fmt=\w+$/, ""));
      const xml = await xmlResponse.text();
      const parsed = await parseStringPromise(xml);

      if (!parsed?.transcript?.text) throw new Error("Invalid caption format");

      const structured = parsed.transcript.text.map(e => ({
        text: e._ || "",
        start: parseFloat(e.$.start || 0),
        duration: parseFloat(e.$.dur || 0)
      })).filter(e => e.text.trim().length > 0);

      const plainText = structured.map(e => e.text).join(" ").replace(/\s+/g, " ").trim();

      return { structured, plainText, trackInfo: { name: track.name?.simpleText, language: track.languageCode, isAutoGenerated: track.kind === "asr" } };

    } catch (err) {
      lastError = err;
      continue;
    }
  }

  throw new Error(`All clients failed. Last error: ${lastError?.message}`);
}

function extractVideoId(videoUrlOrId) {
  if (/^[a-zA-Z0-9_-]{11}$/.test(videoUrlOrId)) return videoUrlOrId;
  try {
    const url = new URL(videoUrlOrId);
    if (url.hostname.includes('youtube.com')) return url.searchParams.get('v');
    if (url.hostname.includes('youtu.be')) return url.pathname.slice(1);
    if (url.pathname.includes('/embed/')) return url.pathname.split('/embed/')[1]?.split('?')[0];
  } catch {}
  const match = videoUrlOrId.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/);
  return match ? match[1] : videoUrlOrId;
}

module.exports = { getTranscript, extractVideoId };
