// youtubeTranscript.js - YouTube Data API v3 version
const fetch = require("node-fetch");

/**
 * Main transcript extraction using YouTube Data API v3
 * @param {string} videoUrlOrId - YouTube video URL or ID
 * @param {string} language - Language code (default: 'en')
 */
async function getTranscript(videoUrlOrId, language = "en") {
  const videoId = extractVideoId(videoUrlOrId);
  if (!process.env.YOUTUBE_API_KEY) {
    throw new Error("YOUTUBE_API_KEY not set in environment variables");
  }

  try {
    // Step 1: List captions for the video
    const listUrl = `https://www.googleapis.com/youtube/v3/captions?part=snippet&videoId=${videoId}&key=${process.env.YOUTUBE_API_KEY}`;
    const listResp = await fetch(listUrl);
    const listData = await listResp.json();

    if (!listData.items || listData.items.length === 0) {
      throw new Error("No captions found for this video");
    }

    // Step 2: Find desired language
    let caption = listData.items.find(c => c.snippet.language === language) || listData.items[0];

    // Step 3: Download the caption track (must be in 'srt' format for plain text)
    const downloadUrl = `https://www.googleapis.com/youtube/v3/captions/${caption.id}?tfmt=srt&key=${process.env.YOUTUBE_API_KEY}`;
    const downloadResp = await fetch(downloadUrl, {
      headers: {
        "Accept": "application/octet-stream"
      }
    });

    if (!downloadResp.ok) {
      throw new Error(`Failed to download captions: ${downloadResp.status}`);
    }

    const srtText = await downloadResp.text();

    // Step 4: Convert SRT to structured transcript
    const structured = parseSRT(srtText);
    const plainText = structured.map(e => e.text).join(" ").replace(/\s+/g, " ").trim();

    return {
      structured,
      plainText,
      trackInfo: {
        name: caption.snippet.name || "YouTube Caption",
        language: caption.snippet.language,
        isAutoGenerated: caption.snippet.trackKind === "ASR",
        extractedWith: "YouTube Data API v3"
      }
    };
  } catch (error) {
    throw new Error(`YouTube API transcript failed: ${error.message}`);
  }
}

/**
 * Parse SRT content into structured transcript
 */
function parseSRT(srt) {
  const regex = /(\d+)\s+([\d:,]+) --> ([\d:,]+)\s+([\s\S]*?)(?=\n{2,}|$)/g;
  const result = [];
  let match;

  while ((match = regex.exec(srt)) !== null) {
    const start = timeToSeconds(match[2]);
    const end = timeToSeconds(match[3]);
    const text = match[4].replace(/\r/g, "").trim();
    if (text) {
      result.push({ start, duration: end - start, text });
    }
  }

  return result;
}

/**
 * Convert SRT timestamp (hh:mm:ss,ms) to seconds
 */
function timeToSeconds(timestamp) {
  const [hms, ms] = timestamp.split(",");
  const [h, m, s] = hms.split(":").map(Number);
  return h * 3600 + m * 60 + s + Number(ms) / 1000;
}

/**
 * Extract video ID from URL or return as-is if already an ID
 */
function extractVideoId(videoUrlOrId) {
  if (/^[a-zA-Z0-9_-]{11}$/.test(videoUrlOrId)) return videoUrlOrId;

  try {
    const url = new URL(videoUrlOrId);
    if (url.hostname.includes("youtube.com")) {
      return url.searchParams.get("v");
    }
    if (url.hostname.includes("youtu.be")) {
      return url.pathname.slice(1);
    }
    if (url.pathname.includes("/embed/")) {
      return url.pathname.split("/embed/")[1]?.split("?")[0];
    }
    if (url.pathname.includes("/shorts/")) {
      return url.pathname.split("/shorts/")[1]?.split("?")[0];
    }
  } catch (err) {
    const match = videoUrlOrId.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/);
    if (match) return match[1];
  }

  return videoUrlOrId;
}

module.exports = { getTranscript, extractVideoId };
