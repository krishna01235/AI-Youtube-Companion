let fetch;
let parseStringPromise;
const { Innertube } = require("youtubei.js");

// Initialize dependencies
async function initializeDependencies() {
  if (!fetch) {
    if (typeof globalThis !== 'undefined' && globalThis.fetch) {
      fetch = globalThis.fetch;
    } else {
      const nodeFetch = require("node-fetch");
      fetch = nodeFetch.default || nodeFetch;
    }
  }

  if (!parseStringPromise) {
    const xml2js = require("xml2js");
    parseStringPromise = xml2js.parseStringPromise;
  }
}

/**
 * Original scraping version with minimal safe enhancements
 */
async function getTranscriptScraping(videoUrlOrId, language = "en") {
  await initializeDependencies();

  const videoId = extractVideoId(videoUrlOrId);
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;

  try {
    const response = await fetch(videoUrl, {
      headers: {
        // Add standard headers to avoid blocks (SAFE)
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: Video may be unavailable`);
    }
    
    const html = await response.text();
    
    // Keep original API key extraction but add fallback pattern (SAFE)
    let apiKeyMatch = html.match(/"INNERTUBE_API_KEY":"([^"]+)"/);
    if (!apiKeyMatch) {
      // Try alternative pattern as fallback
      apiKeyMatch = html.match(/"innertubeApiKey":"([^"]+)"/);
    }

    if (!apiKeyMatch) {
      throw new Error("Video unavailable or private");
    }

    const apiKey = apiKeyMatch[1];

    // Keep original client config (SAFE - no changes to working logic)
    const playerResponse = await fetch(`https://www.youtube.com/youtubei/v1/player?key=${apiKey}`, {
      method: "POST",
      headers: { 
        "Content-Type": "application/json",
        "User-Agent": "com.google.android.youtube/20.10.38 (Linux; U; Android 13) gzip"
      },
      body: JSON.stringify({
        context: {
          client: {
            clientName: "ANDROID",
            clientVersion: "20.10.38",
            androidSdkVersion: 33,
            osName: "Android",
            osVersion: "13",
          }
        },
        videoId
      })
    });

    const playerData = await playerResponse.json();
    const tracks = playerData?.captions?.playerCaptionsTracklistRenderer?.captionTracks;

    if (!tracks || tracks.length === 0) {
      throw new Error("No captions found");
    }

    // Enhanced language matching (SAFE - only improves existing logic)
    let track = tracks.find(t => t.languageCode === language);
    if (!track) {
      // Try language variants (e.g., 'en-US', 'en-GB' for 'en')
      track = tracks.find(t => t.languageCode?.startsWith(language));
    }
    if (!track) {
      track = tracks[0]; // Original fallback
    }

    const baseUrl = track.baseUrl.replace(/&fmt=\w+$/, "");
    const xmlResponse = await fetch(baseUrl);
    
    if (!xmlResponse.ok) {
      throw new Error(`Failed to fetch captions: ${xmlResponse.status}`);
    }
    
    const xml = await xmlResponse.text();
    const parsed = await parseStringPromise(xml);

    if (!parsed?.transcript?.text) {
      throw new Error("Invalid caption format");
    }

    const structuredTranscript = parsed.transcript.text
      .map(entry => ({
        text: entry._ || "",
        start: parseFloat(entry.$.start || 0),
        duration: parseFloat(entry.$.dur || 0),
      }))
      .filter(entry => entry.text.trim().length > 0);

    const plainText = structuredTranscript
      .map(entry => entry.text)
      .join(" ")
      .replace(/\[.*?\]/g, "")
      .replace(/\s+/g, " ")
      .trim();

    return {
      structured: structuredTranscript,
      plainText,
      trackInfo: {
        name: track.name?.simpleText,
        language: track.languageCode,
        isAutoGenerated: track.kind === "asr"
      }
    };

  } catch (error) {
    // Enhanced error message (SAFE)
    throw new Error(`Scraping failed: ${error.message}`);
  }
}

/**
 * Enhanced youtubei.js fallback with better error handling (SAFE)
 */
async function getTranscriptWithYTJS(videoUrlOrId, language = "en") {
  const videoId = extractVideoId(videoUrlOrId);
  
  try {
    const yt = await Innertube.create();
    const info = await yt.getInfo(videoId);

    if (!info.captions?.caption_tracks?.length) {
      throw new Error("No captions found");
    }

    const tracks = info.captions.caption_tracks;
    
    // Enhanced language matching (SAFE)
    let track = tracks.find(t => t.language_code === language);
    if (!track) {
      track = tracks.find(t => t.language_code?.startsWith(language));
    }
    if (!track) {
      track = tracks[0];
    }

    const transcript = await track.download();
    
    if (!transcript || transcript.length === 0) {
      throw new Error("Downloaded transcript is empty");
    }

    const structuredTranscript = transcript.map(entry => ({
      text: entry.text,
      start: entry.start,
      duration: entry.duration,
    }));

    const plainText = structuredTranscript.map(e => e.text).join(" ").trim();

    return {
      structured: structuredTranscript,
      plainText,
      trackInfo: {
        name: track.name,
        language: track.language_code,
        isAutoGenerated: track.kind === "asr"
      }
    };
  } catch (error) {
    throw new Error(`youtubei.js failed: ${error.message}`);
  }
}

/**
 * Main entry with optional enhanced logging
 */
async function getTranscript(videoUrlOrId, language = "en") {
  const enableDebugLogging = process.env.NODE_ENV === 'development' || process.env.YOUTUBE_DEBUG === 'true';
  
  if (enableDebugLogging) {
    const videoId = extractVideoId(videoUrlOrId);
    console.log(`üé• Attempting to get transcript for video: ${videoId}`);
  }
  
  let transcript;
  try {
    if (enableDebugLogging) console.log("üì° Trying scraping method...");
    transcript = await getTranscriptScraping(videoUrlOrId, language);
    if (enableDebugLogging) console.log("‚úÖ Scraping successful");
  } catch (e) {
    if (enableDebugLogging) console.warn("‚ö†Ô∏è Scraping failed, trying youtubei.js fallback:", e.message);
    transcript = await getTranscriptWithYTJS(videoUrlOrId, language);
    if (enableDebugLogging) console.log("‚úÖ youtubei.js successful");
  }
  return transcript;
}

/**
 * Enhanced video ID extraction (SAFE - more comprehensive patterns)
 */
function extractVideoId(videoUrlOrId) {
  if (/^[a-zA-Z0-9_-]{11}$/.test(videoUrlOrId)) {
    return videoUrlOrId;
  }
  
  try {
    const url = new URL(videoUrlOrId);
    if (url.hostname.includes('youtube.com')) {
      const videoId = url.searchParams.get('v');
      if (videoId) return videoId;
    }
    if (url.hostname.includes('youtu.be')) {
      return url.pathname.slice(1);
    }
    if (url.pathname.includes('/embed/')) {
      return url.pathname.split('/embed/')[1]?.split('?')[0];
    }
    // Add YouTube Shorts support (SAFE)
    if (url.pathname.includes('/shorts/')) {
      return url.pathname.split('/shorts/')[1]?.split('?')[0];
    }
  } catch (err) {
    const match = videoUrlOrId.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/);
    if (match) return match[1];
  }
  return videoUrlOrId;
}

module.exports = { 
  getTranscript,
  extractVideoId 
};